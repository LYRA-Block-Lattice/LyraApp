@namespace UserLibrary.Components

@using CoinGecko.Clients
@using CoinGecko.Interfaces
@using Fluxor
@using Lyra.Core.API
@using Lyra.Core.Blocks
@using Lyra.Data.API
@using Lyra.Data.Crypto
@using Microsoft.Extensions.Configuration
@using Nebula.Store.WebWalletUseCase
@using UserLibrary.Data
@inject IConfiguration _config
@inject ILyraAPI lyraClient
@inject PeriodicExecutor PeriodicExecutor
@implements IDisposable

@if (busy)
{
    <div style="z-index: 5;" class="spinner"></div>
}

<div class="swc">
    <div class="rndcc mud-elevation-2">
        <div class="ipt">
            <div>
                <MudNumericField T="decimal" Label="From" HideSpinButtons="true"
                                 Style="font-size: 24px; " DisableUnderLine
                                 @bind-Value="@amount1" />
            </div>
            <div class="algb">
                <TokenSelect Tokens="@tickers" @ref="@sel1" ValueChanged="@(a => Ticker1 = a)" />

            </div>
        </div>
        <div class="ipt">
            <div title="Estimated total value. Only for reference.">@value1</div>
            <div>Balance: @($"{balance1:N8}")</div>
        </div>
    </div>
    <div>
        <div class="arrdir">
            <MudIcon Icon="@Icons.Filled.ArrowDownward" Color="Color.Secondary"
                Size="Size.Medium"
                           @onclick="@DoSwapTicker"></MudIcon>
        </div>
    </div>

    <div class="rndcc mud-elevation-2">
        <div class="ipt">
            <div>
                <MudNumericField T="decimal" Label="To" HideSpinButtons="true" Style="font-size: 24px;"
                                 DisableUnderLine @bind-Value="@amount2" />
            </div>
            <div>
                <TokenSelect Tokens="@tickers" @ref="@sel2" ValueChanged="@(a => Ticker2 = a)" />
            </div>
        </div>
        <div class="ipt">
            <div title="Estimated total value. Only for reference.">@value2</div>
            <div>Balance: @($"{balance2:N8}")</div>
        </div>
    </div>
    <div style="padding: 30px">
        @if (walletState.Value.wallet == null)
        {
            <a href="/wallet">
                <MudButton Variant="Variant.Filled" FullWidth="true" Color="Color.Primary" class="rounded-pill">
                    <MudIcon Icon="@Icons.Filled.LockOpen" Title="Unlock" />
                    Open Wallet
                </MudButton>
            </a>
        }
        else
        {
            <MudButton Variant="Variant.Filled" FullWidth="true" Disabled="@(!canswap || swapping)" Color="Color.Primary" OnClick="@DoSwap" class="rounded-pill">

                @if (swapping)
                {
                    <MudProgressCircular Color="Color.Secondary" Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                    <MudText Class="ms-2">Processing</MudText>
                }
                else
                {
                    <MudIcon Icon="@Icons.Filled.SwapCalls" Title="Swap" />
                    <MudText>Swap</MudText>
                }
            </MudButton>
        }
    </div>

    <div style="font-size: smaller;">
            <div class="ipt" title="Price queried from CoinGecko. Only for reference.">
                <div>LYR external price</div>
                <div>$ @lyrprice</div>
            </div>
            <div class="ipt" title="Price calculated from liquidate pool. Only for reference.">
                <div>LYR internal price</div>
                <div>$ @lyrintprice</div>
            </div>
    @if (haspoolinfo && canswap)
    {

            <div class="ipt">
                <div>Estimated ratio</div>
                <div>@calprice</div>
            </div>
            <div class="ipt">
                <div>You will sell</div>
                <div>@calsell</div>
            </div>
            <div class="ipt">
                <div>You will get</div>
                <div>@calget</div>
            </div>
            <div class="ipt">
                <div>Price Impact</div>
                <div>@calimpact</div>
            </div>
            <div class="ipt">
                <div>Pool Fee</div>
                <div>@calprofee</div>
            </div>
            <div class="ipt">
                <div>Network Fee</div>
                <div>@calnodfee</div>
            </div>
        
    }

    @if (haspoolinfo)
    {
        <div class="ipt">
            <div>Token Pair</div>
            <div>@pairinfo</div>
        </div>
        <div class="iptct">
            <div>Total Liquidate</div>
            <div>@pairliquid</div>
        </div>

        <div class="ipt">
            <div>Your Share</div>
            <div>@pairshare</div>
        </div>
    }
    else
    {
        <div>
            <div style="align-content:center;">Please select a token pair.</div>
        </div>

    }

    </div>

</div>

@code {
    [Inject]
    private IState<WebWalletState> walletState { get; set; }

    [Inject]
    private IDispatcher Dispatcher { get; set; }

    [Inject] ISnackbar Snackbar { get; set; }
    double intervalBeforeMsgClose = 2000;

    bool busy;

    RenderFragment value1, value2;

    private decimal _amount1;
    public decimal amount1
    {
        get
        {
            return _amount1;
        }
        set
        {
            if (_amount1 != value)
            {
                _amount1 = value;
                updateBtn1(_amount1);
            }
            else
                _amount1 = value;
        }
    }

    private decimal _amount2;
    public decimal amount2
    {
        get
        {
            return _amount2;
        }
        set
        {
            if (_amount2 != value)
            {
                _amount2 = value;
                updateBtn2(_amount2);
            }
            else
                _amount2 = value;
        }
    }

    decimal lyrprice, trxprice, lyrintprice;   // int price: internal price calculated by pool
    decimal balance1, balance2;
    TokenSelect sel1, sel2;
    List<Ticker> tickers;
    Ticker selectedTicker1;
    Ticker selectedTicker2;

    private Ticker Ticker1
    {
        get { return selectedTicker1; }
        set
        {
            selectedTicker1 = value;
            UpdateBalance();
            ChangePool();
        }
    }

    private Ticker Ticker2
    {
        get { return selectedTicker2; }
        set
        {
            selectedTicker2 = value;
            UpdateBalance();
            ChangePool();
        }
    }

    RenderFragment pairinfo, pairliquid, pairshare;
    bool haspoolinfo = false;
    bool canswap;
    bool swapping;

    RenderFragment calprice, calsell, calget, calimpact, calprofee, calnodfee;

    string token0, token1;
    TransactionBlock poollatest;
    decimal price;
    decimal minrecv;
    decimal lyraprice;

    protected override void OnInitialized()
    {
        PeriodicExecutor.StartExecuting();
        Dispatcher.Dispatch(new WebWalletChangeTitleAction { title = "Lyra Swap" });
        PeriodicExecutor.JobExecuted += HandleJobExecuted;
        base.OnInitialized();
    }

    public void Dispose()
    {
        PeriodicExecutor.JobExecuted -= HandleJobExecuted;
    }

    void HandleJobExecuted(object sender, JobExecutedEventArgs e)
    {
        // price updated
        trxprice = e.prices["tron"];
        lyrprice = e.prices["lyra"];
        lyrintprice = e.prices["LYR"];

        // update pool
        _ = Task.Run(async () =>
        {
            await InvokeAsync(() => StateHasChanged());
            try
            {
                await UpdatePool();
            }
            catch(Exception ex)
            {
                Console.WriteLine($"In HandleTimer: {ex}");
            }            
        });
    }

    private void UpdateValue()
    {
        if (Ticker1 == null)
        {
            value1 =
    @<div></div>
    ;
        }
        else
        {
            decimal val1 = 0;
            if (Ticker1.dbname == "LYR")
                val1 = lyrprice;
            else if (Ticker1.dbname == "tether/TRX")
                val1 = trxprice;
            else if (Ticker1.dbname == "tether/USDT")
                val1 = 1m;
            else if (price > 0)
            {
                // then ticker2 is LYR. price is x tik1 to 1 tik2
                val1 = lyrprice / price;
            }

            if (val1 == 0)
            {
                value1 =
    @<div></div>
    ;
            }
            else
            {
                var val1str = $"{Math.Round(val1 * amount1, 2)}";
                value1 =
    @<div>~$ @val1str</div>
    ;
            }

        }

        if (Ticker2 == null)
        {
            value2 =
    @<div></div>
    ;
        }
        else
        {
            decimal val2 = 0;
            if (Ticker2.dbname == "LYR")
                val2 = lyrprice;
            else if (Ticker2.dbname == "tether/TRX")
                val2 = trxprice;
            else if (Ticker2.dbname == "tether/USDT")
                val2 = 1m;
            else if (price > 0)
            {
                // then ticker1 is LYR. price is x tik1 to 1 tik2
                val2 = lyrprice * price;
            }

            if (val2 == 0)
            {
                value2 =
    @<div></div>
    ;
            }
            else
            {
                var val2str = $"{Math.Round(val2 * amount2, 2)}";
                value2 =
    @<div>~$ @val2str</div>
    ;
            }
        }
    }

    private void DoSwapTicker()
    {
        (selectedTicker1, selectedTicker2) = (selectedTicker2, selectedTicker1);
        (sel1.Value, sel2.Value) = (sel2.Value, sel1.Value);
        (amount1, amount2) = (amount2, amount1);
        UpdateBalance();
        updateBtn1(amount1);
    }

    private string GN(string dbname)
    {
        return dbname.Replace("tether/", "$");
    }

    private async Task DoSwap()
    {
        swapping = true;
        busy = true;
        var result = await walletState.Value.wallet.SwapTokenAsync(token0, token1,
            selectedTicker1.dbname, amount1, minrecv);

        if (result.Successful())
        {
            Snackbar.Add("Token Swap Success! Waiting for pool updating...", Severity.Success);
            await Task.Delay(3000);

            Snackbar.Add("Refresh pool and wallet...", Severity.Info);
            await walletState.Value.wallet.SyncAsync(null);

            var lc = LyraRestClient.Create(_config["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");
            var existspool = await lc.GetPoolAsync(selectedTicker1.dbname, selectedTicker2.dbname);
            if (existspool.Successful())
            {
                Snackbar.Add("Updated.", Severity.Success);

                poollatest = existspool.GetBlock() as TransactionBlock;
                token0 = existspool.Token0;
                token1 = existspool.Token1;
                CreatePoolInfo(poollatest);
            }
            else
            {
                Snackbar.Add($" Pool refresh failed: {existspool.ResultCode}", Severity.Error);
            }

            updateBtn1(amount1);
            UpdateBalance();

            swapping = false;
        }
        else
            Snackbar.Add($"Error Swap Token: {result.ResultCode}", Severity.Error);

        swapping = false;
        busy = false;
    }

    private void updateBtn1(decimal? a)
    {
        if (selectedTicker1 != null && poollatest != null && amount1 > 0 && token0 != null)
        {
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                selectedTicker1.dbname, amount1, 0);
            _amount2 = swapcal.MinimumReceived;
            amount2 = swapcal.MinimumReceived;

            canswap = amount1 > 0 && amount1 <= balance1
            && selectedTicker1 != null && selectedTicker2 != null
                && selectedTicker1 != selectedTicker2;

            updateBtn(amount1);
        }
        else
        {
            canswap = false;
        }
    }

    private void updateBtn2(decimal? a)
    {
        if (selectedTicker2 != null && poollatest != null && amount2 > 0 && token0 != null)
        {
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                selectedTicker2.dbname, amount2, 0);

            _amount1 = swapcal.MinimumReceived;
            amount1 = swapcal.MinimumReceived;

            canswap = amount2 > 0 && amount2 < balance2
                && selectedTicker1 != null && selectedTicker2 != null
                && selectedTicker1 != selectedTicker2;

            updateBtn(amount2);
        }
        else
        {
            canswap = false;
        }
    }
    private void updateBtn(decimal a)
    {
        if (selectedTicker1 != null && canswap && amount1 > 0 && token0 != null)
        {
            var fromticker = selectedTicker1;
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                fromticker.dbname, amount1, 0);
            var sell = $"{amount1} {fromticker}";
            calsell =
    @<div>@sell</div>
    ;

            price = swapcal.Price;
            var pricestr = $"{Math.Round(price, 8)} {selectedTicker1} per {selectedTicker2}";
            calprice =
    @<div>@pricestr</div>
    ;

            minrecv = swapcal.MinimumReceived;
            var minget = $"{swapcal.MinimumReceived} {selectedTicker2}";
            calget =
    @<div>@minget</div>
    ;

            var imp = $"{swapcal.PriceImpact * 100} %";
            calimpact =
    @<div>@imp</div>
    ;

            var feen = $"{swapcal.PayToAuthorizer} LYR";
            var feep = $"{swapcal.PayToProvider} {fromticker}";
            calnodfee =
    @<div>@feen</div>
    ;
            calprofee =
    @<div>@feep</div>
    ;
        }

        ChangePool();
    }

    private void OnSelectedItemChangedHandler1()
    {
        UpdateBalance();
        ChangePool();
    }
    private void OnSelectedItemChangedHandler2()
    {
        UpdateBalance();
        ChangePool();
    }

    private void ChangePool()
    {
        _ = Task.Run(async () => { 
            try
            {
                await UpdatePool(); 
            }
            catch(Exception ex)
            {
                Console.WriteLine("In UpdatePool: " + ex.Message);
            }
        });
    }

    private async Task UpdatePool()
    {
        await InvokeAsync(() => StateHasChanged());

        if (!busy && selectedTicker1 != null && selectedTicker2 != null && selectedTicker1 != selectedTicker2)
        {
            busy = true;

            var lc = LyraRestClient.Create(_config["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");

            try
            {
                var existspool = await lc.GetPoolAsync(selectedTicker1.dbname, selectedTicker2.dbname);
                if (existspool.Successful())
                {
                    poollatest = existspool.GetBlock() as TransactionBlock;
                    token0 = existspool.Token0;
                    token1 = existspool.Token1;
                }
                else
                {
                    poollatest = null;
                    token0 = null;
                    token1 = null;
                }

                CreatePoolInfo(poollatest);

                updateBtn1(amount1);
                UpdateBalance();
                UpdateValue();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"In UpdatePool: {ex}");
            }
            finally
            {
                busy = false;
                await InvokeAsync(() => StateHasChanged());
            }
        }    
    }

    private void UpdateBalance()
    {
        if (walletState.Value.wallet != null)
        {
            var blk = walletState.Value.wallet.GetLatestBlock();

            if (selectedTicker1 != null)
                if (blk != null && blk.Balances.ContainsKey(selectedTicker1.dbname))
                    balance1 = blk.Balances[selectedTicker1.dbname].ToBalanceDecimal();
                else
                    balance1 = 0;

            if (selectedTicker2 != null)
                if (blk != null && blk.Balances.ContainsKey(selectedTicker2.dbname))
                    balance2 = blk.Balances[selectedTicker2.dbname].ToBalanceDecimal();
                else
                    balance2 = 0;

            Dispatcher.Dispatch(new WebWalletRefreshBalanceAction { wallet = walletState.Value.wallet });
        }

        //InvokeAsync(() => StateHasChanged());
    }



    private async Task OpenSwapUI()
    {
        busy = true;
        var lc = LyraRestClient.Create(_config["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");

        // for api sign only
        var pk = "n4uh7o2kAerPZQSNBRirzA3pSUBEuEhs6r7oRwpV6Dgbs3FvY";
        var pub = "LBRzScs8NwMcr7U8i9a8sSWETseWf3TLge4CVJy6as24hSB4hwtZ5jKTbHJdoVZBJiNC2LpjN9MQB719Py9YxXo2xpLxnS";

        var lsbret = await lc.GetLastServiceBlockAsync();

        var sign = Signatures.GetSignature(pk, (lsbret.GetBlock() as ServiceBlock).Hash, pub);
        var tokens = await lc.GetTokenNamesAsync(pub, sign, "(null)");

        tickers = tokens.Entities
            .Where(a => !a.StartsWith("unittest/"))
            .Select(a => new Ticker
                {
                    dbname = a,
                    Name = a.Replace("tether/", "$")
                })
            .OrderBy(a => a.Name)
            .ToList();
        tickers.Insert(0, new Ticker { dbname = "LYR", Name = "LYR" });


        busy = false;
    }

    bool init;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !init)
        {
            init = true;
            Snackbar.Add($"Initialize Swap App... ", Severity.Info);

            try
            {
                if (walletState.Value.wallet != null)
                    await walletState.Value.wallet.SyncAsync(null);
                await OpenSwapUI();

                Snackbar.Add($"Swap App is ready. ", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Init refresh failed: {ex.Message}", Severity.Error);
            }

            StateHasChanged();
            init = false;
        }
    }


    private void CreatePoolInfo(TransactionBlock platest)
    {
        if (platest != null)
        {
            var info = $"{GN(token0)} vs {GN(token1)}";
            pairinfo =
    @<div>@info</div>
    ;

            if (platest.Balances.ContainsKey(token0))
            {
                var line1 = $"{platest.Balances[token0].ToBalanceDecimal()} {GN(token0)}";
                var line2 = $"{platest.Balances[token1].ToBalanceDecimal()} {GN(token1)}";
                pairliquid =
    @<div style="text-align:end">
        <div>@line1</div>
        <div>@line2</div>
    </div>
    ;
            }
            else
            {
                pairliquid =
    @<div>No Liquidate in Pool</div>
    ;
            }
        }
        else
        {
            pairinfo =
    @<div>No pool for selected token pair.</div>
    ;

            pairliquid =
    @<div>No Liquidate in Pool</div>
    ;
        }


        var pool = platest as IPool;
        if (pool != null && walletState.Value.wallet != null)
        {
            if (pool.Shares.ContainsKey(walletState.Value.wallet.AccountId))
            {
                var shareinfo = $"{Math.Round(pool.Shares[walletState.Value.wallet.AccountId].ToRitoDecimal() * 100, 4)} %";
                pairshare =
    @<div>@shareinfo</div>
    ;
            }
            else
            {
                pairshare =
    @<div>No Share in Pool</div>
    ;
            }
        }
        else
        {
            pairshare =
    @<div>No Share in Pool</div>
    ;
        }

    ;

        haspoolinfo = platest != null;
    }
}
